# Supercomputing for Science

â€”

### Vandana Kalithkar

I am a neuroscience and data science double major, and I aim to be a researcher. I want to integrate a strong computational background into the neuroscience research I engage with. In my previous research and classroom experiences, I have been in situations where it would have been useful to know how to use the school's HPC for larger jobs. At the time, I hesitated to actually learn these skills, however. My previous experience here entails trying to use a software that recommends I work in a Linux environment, leading me to try to learn to work with Linux on WSL until I wasted the day barely making any progress. I kicked the metaphorical can down the road further, assuming that eventually I would be forced to learn Linux/Unix in graduate school. This class, Supercomputing for Sciences, unsurprisingly, caught my attention, and I realized I could make this skill acquisition a lot easier on myself through a formalized approach. 

By the end of this course, I want to have developed a more intuitive understanding of the language that these systems are using to communicate. This will allow me to not feel like I am merely fumbling around or wasting time as I try to use them. Additionally, I have yet to actually perform research that requires handling large amounts of scientific data, particularly bioinformatic data, that would require the use of an HPC. Practicing these skills in a classroom environment is a necessary part of my data science track before I find myself in a research situation where there is a lot of pressure to scramble to analyze this data correctly and efficiently. 

I am very motivated to lock down the intuitive understanding of supercomputers and communicating with the HPC, so part of my plan is to ensure that any and all conceptual questions that I have on the smallest details here are answered (either by asking during class, looking it up, or asking generative AI). Without this step, I would not actually feel that I had learned much in the class, nor would I feel confident actually implementing the skills in my research. Already, I have noticed holes in my understanding in file addresses and the basic Linux commands, and I have started to work filling in these knowledge gaps. 

Additionally, when I first learned to code in Java back in high school, my most effective strategy was to attempt to retype elementary code (print lines, function definitions) to first understand the syntax, painstakingly analyzing it line-by-line, and then I would program from scratch with no other outside aids. Doing the first activity with knowledge that I would later do the second would sharpen my focus, forcing myself to pay great attention as I typed the lines out, and then I would subsequently force myself to recall the syntax with the second activity. New project files would all have to be started from scratch without outside material, reinforcing my learning, leading me to begin developing the creative programmatic thinking that my teachers have all tried to cultivate in their students. This approach worked well for me once to learn the syntax and commands of the Java language, so I hope to implement and adapt as necessary when learning to work in the Linux environment.

I aim to use this class in honing the computational research skills that I would not otherwise ever be taught. My understanding of research that involves programming is that it necessitates well-commented, readable, efficient, and overall professional code. Computational research that does not contain documentation is like wet lab research that does not have a methodology section. In short, the lack of documentation reduces reproducibility of the research, since it is unclear what route that we, the researcher, used to obtain our results. This can also rightfully reduce the trust that our peers in the scientific community might have in our work, as there is no clear through-line between the code and the result. My file folder structure, I hope, can maintain this, including clear README documentation with the commands I implemented, transparent for others to use. Additionally, with demarcations between all the different folders I might have for each assignment, I hope that this work and its organizational breakdown is readable to the outside observer. This goes beyond file organization, though. File names and the code itself, including variables, must be descriptive and commented for full readability, if another researcher might wish to reproduce my work.
